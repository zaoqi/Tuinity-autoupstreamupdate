From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <spottedleaf@spottedleaf.dev>
Date: Mon, 4 May 2020 10:06:24 -0700
Subject: [PATCH] Highly optimise single and multi-AABB VoxelShapes and
 collisions


diff --git a/src/main/java/com/tuinity/tuinity/util/CachedLists.java b/src/main/java/com/tuinity/tuinity/util/CachedLists.java
new file mode 100644
index 0000000000000000000000000000000000000000..a54f516ba72806c0470259436f889faa8f6e7586
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/CachedLists.java
@@ -0,0 +1,53 @@
+package com.tuinity.tuinity.util;
+
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.Entity;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.util.UnsafeList;
+import java.util.List;
+
+public class CachedLists {
+
+    static final UnsafeList<AxisAlignedBB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
+    static boolean tempCollisionListInUse;
+
+    public static List<AxisAlignedBB> getTempCollisionList() {
+        if (!Bukkit.isPrimaryThread() || tempCollisionListInUse) {
+            return new UnsafeList<>(16);
+        }
+        tempCollisionListInUse = true;
+        return TEMP_COLLISION_LIST;
+    }
+
+    public static void returnTempCollisionList(List<AxisAlignedBB> list) {
+        if (list != TEMP_COLLISION_LIST) {
+            return;
+        }
+        ((UnsafeList)list).setSize(0);
+        tempCollisionListInUse = false;
+    }
+
+    static final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
+    static boolean tempGetEntitiesListInUse;
+
+    public static List<Entity> getTempGetEntitiesList() {
+        if (!Bukkit.isPrimaryThread() || tempGetEntitiesListInUse) {
+            return new UnsafeList<>(16);
+        }
+        tempGetEntitiesListInUse = true;
+        return TEMP_GET_ENTITIES_LIST;
+    }
+
+    public static void returnTempGetEntitiesList(List<Entity> list) {
+        if (list != TEMP_GET_ENTITIES_LIST) {
+            return;
+        }
+        ((UnsafeList)list).setSize(0);
+        tempGetEntitiesListInUse = false;
+    }
+
+    public static void reset() {
+        TEMP_COLLISION_LIST.completeReset();
+        TEMP_GET_ENTITIES_LIST.completeReset();
+    }
+}
diff --git a/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java b/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java
new file mode 100644
index 0000000000000000000000000000000000000000..b321ad51635949d07b9b818f2940a31bca1a74e3
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java
@@ -0,0 +1,162 @@
+package com.tuinity.tuinity.voxel;
+
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.EnumDirection;
+import net.minecraft.server.VoxelShape;
+import net.minecraft.server.VoxelShapes;
+import java.util.ArrayList;
+import java.util.List;
+
+public final class AABBVoxelShape extends VoxelShape {
+
+    public final AxisAlignedBB aabb;
+
+    public AABBVoxelShape(AxisAlignedBB aabb) {
+        super(VoxelShapes.getFullUnoptimisedCube().getShape());
+        this.aabb = aabb;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.aabb.isEmpty();
+    }
+
+    @Override
+    public double b(EnumDirection.EnumAxis enumdirection_enumaxis) { // getMin
+        switch (enumdirection_enumaxis.ordinal()) {
+            case 0:
+                return this.aabb.minX;
+            case 1:
+                return this.aabb.minY;
+            case 2:
+                return this.aabb.minZ;
+            default:
+                throw new IllegalStateException("Unknown axis requested");
+        }
+    }
+
+    @Override
+    public double c(EnumDirection.EnumAxis enumdirection_enumaxis) { //getMax
+        switch (enumdirection_enumaxis.ordinal()) {
+            case 0:
+                return this.aabb.maxX;
+            case 1:
+                return this.aabb.maxY;
+            case 2:
+                return this.aabb.maxZ;
+            default:
+                throw new IllegalStateException("Unknown axis requested");
+        }
+    }
+
+    @Override
+    public AxisAlignedBB getBoundingBox() { // rets bounding box enclosing this entire shape
+        return this.aabb;
+    }
+
+    // enum direction axis is from 0 -> 2, so we keep the lower bits for direction axis.
+    @Override
+    protected double a(EnumDirection.EnumAxis enumdirection_enumaxis, int i) { // getPointFromIndex
+        switch (enumdirection_enumaxis.ordinal() | (i << 2)) {
+            case (0 | (0 << 2)):
+                return this.aabb.minX;
+            case (1 | (0 << 2)):
+                return this.aabb.minY;
+            case (2 | (0 << 2)):
+                return this.aabb.minZ;
+            case (0 | (1 << 2)):
+                return this.aabb.maxX;
+            case (1 | (1 << 2)):
+                return this.aabb.maxY;
+            case (2 | (1 << 2)):
+                return this.aabb.maxZ;
+            default:
+                throw new IllegalStateException("Unknown axis requested");
+        }
+    }
+
+    private DoubleList cachedListX;
+    private DoubleList cachedListY;
+    private DoubleList cachedListZ;
+
+    @Override
+    protected DoubleList a(EnumDirection.EnumAxis enumdirection_enumaxis) { // getPoints
+        switch (enumdirection_enumaxis.ordinal()) {
+            case 0:
+                return this.cachedListX == null ? this.cachedListX = DoubleArrayList.wrap(new double[] { this.aabb.minX, this.aabb.maxX }) : this.cachedListX;
+            case 1:
+                return this.cachedListY == null ? this.cachedListY = DoubleArrayList.wrap(new double[] { this.aabb.minY, this.aabb.maxY }) : this.cachedListY;
+            case 2:
+                return this.cachedListZ == null ? this.cachedListZ = DoubleArrayList.wrap(new double[] { this.aabb.minZ, this.aabb.maxZ }) : this.cachedListZ;
+            default:
+                throw new IllegalStateException("Unknown axis requested");
+        }
+    }
+
+    @Override
+    public VoxelShape a(double d0, double d1, double d2) { // createOffset
+        return new AABBVoxelShape(this.aabb.offset(d0, d1, d2));
+    }
+
+    @Override
+    public VoxelShape c() { // simplify
+        return this;
+    }
+
+    @Override
+    public void b(VoxelShapes.a voxelshapes_a) { // forEachAABB
+        voxelshapes_a.consume(this.aabb.minX, this.aabb.minY, this.aabb.minZ, this.aabb.maxX, this.aabb.maxY, this.aabb.maxZ);
+    }
+
+    @Override
+    public List<AxisAlignedBB> d() { // getAABBs
+        List<AxisAlignedBB> ret = new ArrayList<>(1);
+        ret.add(this.aabb);
+        return ret;
+    }
+
+    @Override
+    protected int a(EnumDirection.EnumAxis enumdirection_enumaxis, double d0) { // findPointIndexAfterOffset
+        switch (enumdirection_enumaxis.ordinal()) {
+            case 0:
+                return d0 < this.aabb.maxX ? (d0 < this.aabb.minX ? -1 : 0) : 1;
+            case 1:
+                return d0 < this.aabb.maxY ? (d0 < this.aabb.minY ? -1 : 0) : 1;
+            case 2:
+                return d0 < this.aabb.maxZ ? (d0 < this.aabb.minZ ? -1 : 0) : 1;
+            default:
+                throw new IllegalStateException("Unknown axis requested");
+        }
+    }
+
+    @Override
+    protected boolean b(double d0, double d1, double d2) { // containsPoint
+        return this.aabb.contains(d0, d1, d2);
+    }
+
+    @Override
+    public VoxelShape a(EnumDirection enumdirection) { // unknown
+        return super.a(enumdirection);
+    }
+
+    @Override
+    public double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, double d0) { // collide
+        switch (enumdirection_enumaxis.ordinal()) {
+            case 0:
+                return AxisAlignedBB.collideX(this.aabb, axisalignedbb, d0);
+            case 1:
+                return AxisAlignedBB.collideY(this.aabb, axisalignedbb, d0);
+            case 2:
+                return AxisAlignedBB.collideZ(this.aabb, axisalignedbb, d0);
+            default:
+                throw new IllegalStateException("Unknown axis requested");
+        }
+    }
+
+    @Override
+    public boolean intersects(AxisAlignedBB axisalingedbb) {
+        return this.aabb.voxelShapeIntersect(axisalingedbb);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index ed9b2f9adfecdc6d1b9925579ec510657adde11f..6aa9f07336c23150ca72bdf3d45677e8d40ee4e9 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -13,6 +13,149 @@ public class AxisAlignedBB {
     public final double maxY;
     public final double maxZ;
 
+    // Tuinity start
+    public final boolean isEmpty() {
+        return (this.maxX - this.minX) < MCUtil.COLLISION_EPSILON && (this.maxY - this.minY) < MCUtil.COLLISION_EPSILON && (this.maxZ - this.minZ) < MCUtil.COLLISION_EPSILON;
+    }
+
+    public static AxisAlignedBB getBoxForChunk(int chunkX, int chunkZ) {
+        double x = (double)(chunkX << 4);
+        double z = (double)(chunkZ << 4);
+        // use a bounding box bigger than the chunk to prevent entities from entering it on move
+        return new AxisAlignedBB(x - 3*MCUtil.COLLISION_EPSILON, Double.NEGATIVE_INFINITY, z - 3*MCUtil.COLLISION_EPSILON, x + (16.0 + 3*MCUtil.COLLISION_EPSILON), Double.POSITIVE_INFINITY, z + (16.0 + 3*MCUtil.COLLISION_EPSILON), false);
+    }
+
+    /*
+      A couple of rules for VoxelShape collisions:
+      Two shapes only intersect if they are actually more than EPSILON units into each other. This also applies to movement
+      checks.
+      If the two shapes strictly collide, then the return value of a collide call will return a value in the opposite
+      direction of the source move. However, this value will not be greater in magnitude than EPSILON. Collision code
+      will automatically round it to 0.
+     */
+
+    public final boolean voxelShapeIntersect(AxisAlignedBB other) {
+        return this.voxelShapeIntersect(other.minX, other.minY, other.minZ, other.maxX, other.maxY, other.maxZ);
+    }
+
+    public final boolean voxelShapeIntersect(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
+        return (this.minX - maxX) < -MCUtil.COLLISION_EPSILON && (this.maxX - minX) > MCUtil.COLLISION_EPSILON &&
+               (this.minY - maxY) < -MCUtil.COLLISION_EPSILON && (this.maxY - minY) > MCUtil.COLLISION_EPSILON &&
+               (this.minZ - maxZ) < -MCUtil.COLLISION_EPSILON && (this.maxZ - minZ) > MCUtil.COLLISION_EPSILON;
+    }
+
+    public static double collideX(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
+        if (target.isEmpty() || source.isEmpty()) {
+            return source_move;
+        }
+        if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
+            return 0.0;
+        }
+
+        if ((source.minY - target.maxY) < -MCUtil.COLLISION_EPSILON && (source.maxY - target.minY) > MCUtil.COLLISION_EPSILON &&
+                (source.minZ - target.maxZ) < -MCUtil.COLLISION_EPSILON && (source.maxZ - target.minZ) > MCUtil.COLLISION_EPSILON) {
+
+            if (source_move >= 0.0) {
+                double max_move = target.minX - source.maxX; // < 0.0 if no strict collision
+                if (max_move < -MCUtil.COLLISION_EPSILON) {
+                    return source_move;
+                }
+                return Math.min(max_move, source_move);
+            } else {
+                double max_move = target.maxX - source.minX; // > 0.0 if no strict collision
+                if (max_move > MCUtil.COLLISION_EPSILON) {
+                    return source_move;
+                }
+                return Math.max(max_move, source_move);
+            }
+        }
+        return source_move;
+    }
+
+    public static double collideY(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
+        if (target.isEmpty() || source.isEmpty()) {
+            return source_move;
+        }
+        if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
+            return 0.0;
+        }
+
+        if ((source.minX - target.maxX) < -MCUtil.COLLISION_EPSILON && (source.maxX - target.minX) > MCUtil.COLLISION_EPSILON &&
+                (source.minZ - target.maxZ) < -MCUtil.COLLISION_EPSILON && (source.maxZ - target.minZ) > MCUtil.COLLISION_EPSILON) {
+            if (source_move >= 0.0) {
+                double max_move = target.minY - source.maxY; // < 0.0 if no strict collision
+                if (max_move < -MCUtil.COLLISION_EPSILON) {
+                    return source_move;
+                }
+                return Math.min(max_move, source_move);
+            } else {
+                double max_move = target.maxY - source.minY; // > 0.0 if no strict collision
+                if (max_move > MCUtil.COLLISION_EPSILON) {
+                    return source_move;
+                }
+                return Math.max(max_move, source_move);
+            }
+        }
+        return source_move;
+    }
+
+    public static double collideZ(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
+        if (target.isEmpty() || source.isEmpty()) {
+            return source_move;
+        }
+        if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
+            return 0.0;
+        }
+
+        if ((source.minX - target.maxX) < -MCUtil.COLLISION_EPSILON && (source.maxX - target.minX) > MCUtil.COLLISION_EPSILON &&
+                (source.minY - target.maxY) < -MCUtil.COLLISION_EPSILON && (source.maxY - target.minY) > MCUtil.COLLISION_EPSILON) {
+            if (source_move >= 0.0) {
+                double max_move = target.minZ - source.maxZ; // < 0.0 if no strict collision
+                if (max_move < -MCUtil.COLLISION_EPSILON) {
+                    return source_move;
+                }
+                return Math.min(max_move, source_move);
+            } else {
+                double max_move = target.maxZ - source.minZ; // > 0.0 if no strict collision
+                if (max_move > MCUtil.COLLISION_EPSILON) {
+                    return source_move;
+                }
+                return Math.max(max_move, source_move);
+            }
+        }
+        return source_move;
+    }
+
+    public final AxisAlignedBB offsetX(double dx) {
+        return new AxisAlignedBB(this.minX + dx, this.minY, this.minZ, this.maxX + dx, this.maxY, this.maxZ, false);
+    }
+
+    public final AxisAlignedBB offsetY(double dy) {
+        return new AxisAlignedBB(this.minX, this.minY + dy, this.minZ, this.maxX, this.maxY + dy, this.maxZ, false);
+    }
+
+    public final AxisAlignedBB offsetZ(double dz) {
+        return new AxisAlignedBB(this.minX, this.minY, this.minZ + dz, this.maxX, this.maxY, this.maxZ + dz, false);
+    }
+
+    public AxisAlignedBB(double d0, double d1, double d2, double d3, double d4, double d5, boolean dummy) {
+        this.minX = d0;
+        this.minY = d1;
+        this.minZ = d2;
+        this.maxX = d3;
+        this.maxY = d4;
+        this.maxZ = d5;
+    }
+
+    public final AxisAlignedBB expandUpwards(double dy) {
+        return new AxisAlignedBB(this.minX, this.minY, this.minZ, this.maxX, this.maxY + dy, this.maxZ, false);
+    }
+
+    public final AxisAlignedBB expandUpwardsAndCutBelow(double dy) {
+        return new AxisAlignedBB(this.minX, this.maxY, this.minZ, this.maxX, this.maxY + dy, this.maxZ, false);
+    }
+    // Tuinity end
+
     public AxisAlignedBB(double d0, double d1, double d2, double d3, double d4, double d5) {
         this.minX = Math.min(d0, d3);
         this.minY = Math.min(d1, d4);
@@ -185,6 +328,7 @@ public class AxisAlignedBB {
         return new AxisAlignedBB(d0, d1, d2, d3, d4, d5);
     }
 
+    public final AxisAlignedBB offset(double d0, double d1, double d2) { return this.d(d0, d1, d2); } // Tuinity - OBFHELPER
     public AxisAlignedBB d(double d0, double d1, double d2) {
         return new AxisAlignedBB(this.minX + d0, this.minY + d1, this.minZ + d2, this.maxX + d0, this.maxY + d1, this.maxZ + d2);
     }
@@ -193,6 +337,7 @@ public class AxisAlignedBB {
         return new AxisAlignedBB(this.minX + (double) blockposition.getX(), this.minY + (double) blockposition.getY(), this.minZ + (double) blockposition.getZ(), this.maxX + (double) blockposition.getX(), this.maxY + (double) blockposition.getY(), this.maxZ + (double) blockposition.getZ());
     }
 
+    public final AxisAlignedBB offset(Vec3D vec3d) { return this.b(vec3d); } // Tuinity - OBFHELPER
     public AxisAlignedBB c(Vec3D vec3d) {
         return this.d(vec3d.x, vec3d.y, vec3d.z);
     }
@@ -212,6 +357,7 @@ public class AxisAlignedBB {
         return this.e(vec3d.x, vec3d.y, vec3d.z);
     }
 
+    public final boolean contains(double d0, double d1, double d2) { return this.e(d0, d1, d2); } // Tuinity - OBFHELPER
     public boolean e(double d0, double d1, double d2) {
         return d0 >= this.minX && d0 < this.maxX && d1 >= this.minY && d1 < this.maxY && d2 >= this.minZ && d2 < this.maxZ;
     }
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index e52df8096e399c84ff8a2637fdd65ea57d9001d0..cebd808e273dbdb88feb16920dd7a2f60390b34f 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -96,6 +96,7 @@ public class ChunkSection {
         return iblockdata1;
     }
 
+    public final boolean isFullOfAir() { return this.c(); } // Tuinity - OBFHELPER
     public boolean c() {
         return this.nonEmptyBlockCount == 0;
     }
diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index 95ef96286855624590b72d69514b0fc0e08fddba..73163b417af7e522a4509bf9c1ab56d6499be622 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -163,6 +163,7 @@ public class DataPaletteBlock<T> implements DataPaletteExpandable<T> {
         return this.a(j << 8 | k << 4 | i); // Paper - inline
     }
 
+    public final T rawGet(int index) { return this.a(index); } // Tuinity - OBFHELPER
     protected T a(int i) {
         T t0 = this.h.a(this.a.a(i));
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index d0cc0a941c9fe886a536c35961a14e0698ab9ba1..fd633ab8d24753ceebd7183ac2208ff56e14e612 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -137,7 +137,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
     public double D;
     public double E;
     public double F;
-    public float G;
+    public float G; public final float getStepHeight() { return this.G; } // Tuinity - OBFHELPER
     public boolean noclip;
     public float I;
     protected final Random random;
@@ -694,7 +694,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             // Paper end
 
             vec3d = this.a(vec3d, enummovetype);
-            Vec3D vec3d1 = this.g(vec3d);
+            Vec3D vec3d1 = this.performCollision(vec3d); // Tuinity - optimise collisions
 
             if (vec3d1.g() > 1.0E-7D) {
                 this.a(this.getBoundingBox().c(vec3d1));
@@ -897,6 +897,132 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return d0;
     }
 
+    // Tuinity start - optimise entity movement
+    private static double performCollisionsX(AxisAlignedBB currentBoundingBox, double value, List<AxisAlignedBB> potentialCollisions) {
+        for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
+            if (Math.abs(value) < MCUtil.COLLISION_EPSILON) {
+                return 0.0;
+            }
+            AxisAlignedBB target = potentialCollisions.get(i);
+            value = AxisAlignedBB.collideX(target, currentBoundingBox, value);
+        }
+
+        return value;
+    }
+
+    private static double performCollisionsY(AxisAlignedBB currentBoundingBox, double value, List<AxisAlignedBB> potentialCollisions) {
+        for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
+            if (Math.abs(value) < MCUtil.COLLISION_EPSILON) {
+                return 0.0;
+            }
+            AxisAlignedBB target = potentialCollisions.get(i);
+            value = AxisAlignedBB.collideY(target, currentBoundingBox, value);
+        }
+
+        return value;
+    }
+
+    private static double performCollisionsZ(AxisAlignedBB currentBoundingBox, double value, List<AxisAlignedBB> potentialCollisions) {
+        for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
+            if (Math.abs(value) < MCUtil.COLLISION_EPSILON) {
+                return 0.0;
+            }
+            AxisAlignedBB target = potentialCollisions.get(i);
+            value = AxisAlignedBB.collideZ(target, currentBoundingBox, value);
+        }
+
+        return value;
+    }
+
+    private static Vec3D performCollisions(Vec3D moveVector, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> potentialCollisions) {
+        double x = moveVector.x;
+        double y = moveVector.y;
+        double z = moveVector.z;
+
+        if (y != 0.0) {
+            y = Entity.performCollisionsY(axisalignedbb, y, potentialCollisions);
+            if (y != 0.0) {
+                axisalignedbb = axisalignedbb.offsetY(y);
+            }
+        }
+
+        boolean xSmaller = Math.abs(x) < Math.abs(z);
+
+        if (xSmaller && z != 0.0) {
+            z = Entity.performCollisionsZ(axisalignedbb, z, potentialCollisions);
+            if (z != 0.0) {
+                axisalignedbb = axisalignedbb.offsetZ(z);
+            }
+        }
+
+        if (x != 0.0) {
+            x = Entity.performCollisionsX(axisalignedbb, x, potentialCollisions);
+            if (!xSmaller && x != 0.0) {
+                axisalignedbb = axisalignedbb.offsetX(x);
+            }
+        }
+
+        if (!xSmaller && z != 0.0) {
+            z = Entity.performCollisionsZ(axisalignedbb, z, potentialCollisions);
+        }
+
+        return new Vec3D(x, y, z);
+    }
+
+    Vec3D performCollision(Vec3D moveVector) {
+        if (moveVector.getX() == 0.0 && moveVector.getY() == 0.0 && moveVector.getZ() == 0.0) {
+            return moveVector;
+        }
+
+        WorldServer world = ((WorldServer)this.world);
+        AxisAlignedBB currBoundingBox = this.getBoundingBox();
+
+        List<AxisAlignedBB> potentialCollisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList();
+        try {
+            AxisAlignedBB collisionBox;
+            double stepHeight = (double)this.getStepHeight();
+            if (stepHeight > 0.0 && (this.onGround || (moveVector.y < 0.0)) && (moveVector.x != 0.0 || moveVector.z != 0.0)) {
+                // don't bother getting the collisions if we don't need them.
+                if (moveVector.y <= 0.0) {
+                    collisionBox = currBoundingBox.expand(moveVector.x, moveVector.y, moveVector.z).expandUpwards(stepHeight);
+                } else {
+                    collisionBox = currBoundingBox.expand(moveVector.x, Math.max(stepHeight, moveVector.y), moveVector.z);
+                }
+            } else {
+                collisionBox = currBoundingBox.expand(moveVector.x, moveVector.y, moveVector.z);
+            }
+            world.getCollisions(this, collisionBox, potentialCollisions, this instanceof EntityPlayer && !this.world.paperConfig.preventMovingIntoUnloadedChunks);
+
+            Vec3D limitedMoveVector = Entity.performCollisions(moveVector, currBoundingBox, potentialCollisions);
+
+            if (stepHeight > 0.0
+                    && (this.onGround || (limitedMoveVector.y != moveVector.y && moveVector.y < 0.0))
+                    && (limitedMoveVector.x != moveVector.x || limitedMoveVector.z != moveVector.z)) {
+                Vec3D vec3d2 = Entity.performCollisions(new Vec3D(moveVector.x, stepHeight, moveVector.z), currBoundingBox, potentialCollisions);
+                Vec3D vec3d3 = Entity.performCollisions(new Vec3D(0.0, stepHeight, 0.0), currBoundingBox.expand(moveVector.x, 0.0, moveVector.z), potentialCollisions);
+
+                if (vec3d3.y < stepHeight) {
+                    Vec3D vec3d4 = Entity.performCollisions(new Vec3D(moveVector.x, 0.0D, moveVector.z), currBoundingBox.offset(vec3d3), potentialCollisions);
+
+                    if (Entity.getXZSquared(vec3d4) > Entity.getXZSquared(vec3d2)) {
+                        vec3d2 = vec3d4;
+                    }
+                }
+
+                if (Entity.getXZSquared(vec3d2) > Entity.getXZSquared(limitedMoveVector)) {
+                    return vec3d2.add(Entity.performCollisions(new Vec3D(0.0D, -vec3d2.y + moveVector.y, 0.0D), currBoundingBox.offset(vec3d2), potentialCollisions));
+                }
+
+                return limitedMoveVector;
+            } else {
+                return limitedMoveVector;
+            }
+        } finally {
+            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(potentialCollisions);
+        }
+    }
+    // Tuinity end - optimise entity movement
+
     private Vec3D g(Vec3D vec3d) {
         AxisAlignedBB axisalignedbb = this.getBoundingBox();
         VoxelShapeCollision voxelshapecollision = VoxelShapeCollision.a(this);
@@ -932,6 +1058,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return vec3d1;
     }
 
+    public static double getXZSquared(Vec3D vec3d) { return Entity.c(vec3d); } // Tuinity - OBFHELPER
     public static double c(Vec3D vec3d) {
         return vec3d.x * vec3d.x + vec3d.z * vec3d.z;
     }
@@ -2015,10 +2142,12 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return EnumInteractionResult.PASS;
     }
 
+    public final boolean hardCollidesWith(Entity other) { return this.j(other); } // Tuinity - OBFHELPER
     public boolean j(Entity entity) { // Tuinity - diff on change, hard colliding entities override this
         return entity.aY() && !this.isSameVehicle(entity);
     }
 
+    public final boolean collisionBoxIsHard() { return this.aY(); } // Tuinity - OBFHELPER
     public boolean aY() { // Tuinity - diff on change, hard colliding entities override this
         return false;
     }
diff --git a/src/main/java/net/minecraft/server/ICollisionAccess.java b/src/main/java/net/minecraft/server/ICollisionAccess.java
index 25e54a1fadc5d31fb250a3f47524b4f345fc8cc6..b66c802d5e27518069bf42e577bcc9a26c4d873e 100644
--- a/src/main/java/net/minecraft/server/ICollisionAccess.java
+++ b/src/main/java/net/minecraft/server/ICollisionAccess.java
@@ -46,6 +46,11 @@ public interface ICollisionAccess extends IBlockAccess {
     }
 
     default boolean b(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
+        // Tuinity start - allow overriding in WorldServer
+        return this.getCubes(entity, axisalignedbb, predicate);
+    }
+    default boolean getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
+        // Tuinity end - allow overriding in WorldServer
         try { if (entity != null) entity.collisionLoadChunks = true; // Paper
         return this.d(entity, axisalignedbb, predicate).allMatch(VoxelShape::isEmpty);
         } finally { if (entity != null) entity.collisionLoadChunks = false; } // Paper
diff --git a/src/main/java/net/minecraft/server/IEntityAccess.java b/src/main/java/net/minecraft/server/IEntityAccess.java
index bcb95dcb54e29c63925d0c438bf1c862e4570591..882b82d8952d34f6e3c639404d1a1521dedf1bb0 100644
--- a/src/main/java/net/minecraft/server/IEntityAccess.java
+++ b/src/main/java/net/minecraft/server/IEntityAccess.java
@@ -67,7 +67,8 @@ public interface IEntityAccess {
         } else {
             AxisAlignedBB axisalignedbb1 = axisalignedbb.g(1.0E-7D);
 
-            predicate = predicate.and((entity1) -> { // Tuinity - optimise entity hard collisions
+            if (predicate == null) predicate = (e) -> true; // Tuinity - allow nullable
+            predicate = predicate.and((entity1) -> { // Tuinity - optimise entity hard collisions // Tuinity - allow nullable
                 boolean flag;
 
                 if (true || entity1.getBoundingBox().c(axisalignedbb1)) { // Tuinity - always true, wtf did they think this.getEntities(entity, axisalignedbb1) does?
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index ff74be14512a947e81b62d53e616131ca7d7f609..653ba0f1d84af1997d768426d3542c9d465f6c93 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -38,6 +38,7 @@ import java.util.function.Consumer;
 import java.util.function.Supplier;
 
 public final class MCUtil {
+    public static final double COLLISION_EPSILON = 1.0E-7; // Tuinity - Just in case mojang changes this...
     public static final ThreadPoolExecutor asyncExecutor = new ThreadPoolExecutor(
         0, 2, 60L, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(),
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 2ff35fb7f9c7b7479e28b36fda86162cea62016f..106661fae73c76059447b61ed404477309f7b87f 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1321,6 +1321,8 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         }
         // Paper end
 
+        com.tuinity.tuinity.util.CachedLists.reset(); // Tuinity
+
         // Paper start
         long endTime = System.nanoTime();
         long remaining = (TICK_TIME - (endTime - lastTick)) - catchupTime;
diff --git a/src/main/java/net/minecraft/server/Vec3D.java b/src/main/java/net/minecraft/server/Vec3D.java
index 3048ba008147f4647d633f59db812db9021a7c67..84858ba3923845a630d4886ecbd001c60d46131e 100644
--- a/src/main/java/net/minecraft/server/Vec3D.java
+++ b/src/main/java/net/minecraft/server/Vec3D.java
@@ -4,7 +4,7 @@ import java.util.EnumSet;
 
 public class Vec3D implements IPosition {
 
-    public static final Vec3D a = new Vec3D(0.0D, 0.0D, 0.0D);
+    public static final Vec3D a = new Vec3D(0.0D, 0.0D, 0.0D); public static Vec3D getZeroVector() { return Vec3D.a; } // Tuinity - OBFHELPER
     public final double x;
     public final double y;
     public final double z;
@@ -61,6 +61,7 @@ public class Vec3D implements IPosition {
         return this.add(-d0, -d1, -d2);
     }
 
+    public final Vec3D add(Vec3D vec3d) { return this.e(vec3d); } // Tuinity - OBFHELPER
     public Vec3D e(Vec3D vec3d) {
         return this.add(vec3d.x, vec3d.y, vec3d.z);
     }
@@ -109,10 +110,12 @@ public class Vec3D implements IPosition {
         return new Vec3D(this.x * d0, this.y * d1, this.z * d2);
     }
 
+    public final double magnitude() { return this.f(); } // Tuinity - OBFHELPER
     public double f() {
         return (double) MathHelper.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
     }
 
+    public final double magnitudeSquared() { return this.g(); } // Tuinity - OBFHELPER
     public double g() {
         return this.x * this.x + this.y * this.y + this.z * this.z;
     }
diff --git a/src/main/java/net/minecraft/server/VoxelShape.java b/src/main/java/net/minecraft/server/VoxelShape.java
index eb926b74e17fb2f88c1d6ce2fb546541f8e6e274..700660dd93b3090334bb3033d5f5fdd6ab684744 100644
--- a/src/main/java/net/minecraft/server/VoxelShape.java
+++ b/src/main/java/net/minecraft/server/VoxelShape.java
@@ -8,11 +8,11 @@ import javax.annotation.Nullable;
 
 public abstract class VoxelShape {
 
-    protected final VoxelShapeDiscrete a;
+    protected final VoxelShapeDiscrete a; public final VoxelShapeDiscrete getShape() { return this.a; } // Tuinity - OBFHELPER
     @Nullable
     private VoxelShape[] b;
 
-    VoxelShape(VoxelShapeDiscrete voxelshapediscrete) {
+    protected VoxelShape(VoxelShapeDiscrete voxelshapediscrete) { // Tuinity
         this.a = voxelshapediscrete;
     }
 
@@ -48,9 +48,15 @@ public abstract class VoxelShape {
 
     public final VoxelShape offset(double x, double y, double z) { return this.a(x, y, z); } // Paper - OBFHELPER
     public VoxelShape a(double d0, double d1, double d2) {
-        return (VoxelShape) (this.isEmpty() ? VoxelShapes.a() : new VoxelShapeArray(this.a, new DoubleListOffset(this.a(EnumDirection.EnumAxis.X), d0), new DoubleListOffset(this.a(EnumDirection.EnumAxis.Y), d1), new DoubleListOffset(this.a(EnumDirection.EnumAxis.Z), d2)));
+        return (VoxelShape) (this.isEmpty() ? VoxelShapes.a() : new VoxelShapeArray(this.a, new DoubleListOffset(this.a(EnumDirection.EnumAxis.X), d0), new DoubleListOffset(this.a(EnumDirection.EnumAxis.Y), d1), new DoubleListOffset(this.a(EnumDirection.EnumAxis.Z), d2))); // Tuinity - diff on change, copied into VoxelShapeArray override
     }
 
+    // Tuinity start - optimise multi-aabb shapes
+    public boolean intersects(final AxisAlignedBB axisalingedbb) {
+        return VoxelShapes.applyOperation(this, new com.tuinity.tuinity.voxel.AABBVoxelShape(axisalingedbb), OperatorBoolean.AND);
+    }
+    // Tuinity end - optimise multi-aabb shapes
+
     public VoxelShape c() {
         VoxelShape[] avoxelshape = new VoxelShape[]{VoxelShapes.a()};
 
@@ -70,6 +76,7 @@ public abstract class VoxelShape {
         }, true);
     }
 
+    public final List<AxisAlignedBB> getBoundingBoxesRepresentation() { return this.d(); } // Tuinity - OBFHELPER
     public List<AxisAlignedBB> d() {
         List<AxisAlignedBB> list = Lists.newArrayList();
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapeArray.java b/src/main/java/net/minecraft/server/VoxelShapeArray.java
index 3c29cb1452cde1308f630bfcb82876ef19057e8f..d318ec207cdc5f0ef6a0480567225ab476d6e074 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeArray.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeArray.java
@@ -3,6 +3,7 @@ package net.minecraft.server;
 import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 import java.util.Arrays;
+import java.util.List;
 
 public final class VoxelShapeArray extends VoxelShape {
 
@@ -10,11 +11,25 @@ public final class VoxelShapeArray extends VoxelShape {
     private final DoubleList c;
     private final DoubleList d;
 
+    // Tuinity start - optimise multi-aabb shapes
+    static final AxisAlignedBB[] EMPTY = new AxisAlignedBB[0];
+    final AxisAlignedBB[] boundingBoxesRepresentation;
+
+    final double offsetX;
+    final double offsetY;
+    final double offsetZ;
+    // Tuinity end - optimise multi-aabb shapes
+
     protected VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, double[] adouble, double[] adouble1, double[] adouble2) {
         this(voxelshapediscrete, (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble, voxelshapediscrete.b() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble1, voxelshapediscrete.c() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble2, voxelshapediscrete.d() + 1)));
     }
 
     VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, DoubleList doublelist, DoubleList doublelist1, DoubleList doublelist2) {
+        // Tuinity start - optimise multi-aabb shapes
+        this(voxelshapediscrete, doublelist, doublelist1, doublelist2, null, null, 0.0, 0.0, 0.0);
+    }
+    VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, DoubleList doublelist, DoubleList doublelist1, DoubleList doublelist2, VoxelShapeArray original, AxisAlignedBB[] boundingBoxesRepresentation, double offsetX, double offsetY, double offsetZ) {
+        // Tuinity end - optimise multi-aabb shapes
         super(voxelshapediscrete);
         int i = voxelshapediscrete.b() + 1;
         int j = voxelshapediscrete.c() + 1;
@@ -27,6 +42,18 @@ public final class VoxelShapeArray extends VoxelShape {
         } else {
             throw (IllegalArgumentException) SystemUtils.c((Throwable) (new IllegalArgumentException("Lengths of point arrays must be consistent with the size of the VoxelShape.")));
         }
+        // Tuinity start - optimise multi-aabb shapes
+        this.boundingBoxesRepresentation = boundingBoxesRepresentation == null ? this.getBoundingBoxesRepresentation().toArray(EMPTY) : boundingBoxesRepresentation; // Tuinity - optimise multi-aabb shapes
+        if (original == null) {
+            this.offsetX = offsetX;
+            this.offsetY = offsetY;
+            this.offsetZ = offsetZ;
+        } else {
+            this.offsetX = offsetX + original.offsetX;
+            this.offsetY = offsetY + original.offsetY;
+            this.offsetZ = offsetZ + original.offsetZ;
+        }
+        // Tuinity end - optimise multi-aabb shapes
     }
 
     @Override
@@ -42,4 +69,46 @@ public final class VoxelShapeArray extends VoxelShape {
                 throw new IllegalArgumentException();
         }
     }
+
+    // Tuinity start - optimise multi-aabb shapes
+    @Override
+    public VoxelShape a(double d0, double d1, double d2) {
+        if (this == VoxelShapes.getEmptyShape() || this.boundingBoxesRepresentation.length == 0) {
+            return this;
+        }
+        return new VoxelShapeArray(this.a, new DoubleListOffset(this.a(EnumDirection.EnumAxis.X), d0), new DoubleListOffset(this.a(EnumDirection.EnumAxis.Y), d1), new DoubleListOffset(this.a(EnumDirection.EnumAxis.Z), d2), this, this.boundingBoxesRepresentation, d0, d1, d2);
+    }
+
+    public final AxisAlignedBB[] getBoundingBoxesRepresentationRaw() {
+        return this.boundingBoxesRepresentation;
+    }
+
+    public final double getOffsetX() {
+        return this.offsetX;
+    }
+
+    public final double getOffsetY() {
+        return this.offsetY;
+    }
+
+    public final double getOffsetZ() {
+        return this.offsetZ;
+    }
+
+    public final boolean intersects(AxisAlignedBB axisalingedbb) {
+        // this can be optimised by checking an "overall shape" first, but not needed
+        double offX = this.offsetX;
+        double offY = this.offsetY;
+        double offZ = this.offsetZ;
+
+        for (AxisAlignedBB boundingBox : this.boundingBoxesRepresentation) {
+            if (axisalingedbb.voxelShapeIntersect(boundingBox.minX + offX, boundingBox.minY + offY, boundingBox.minZ + offZ,
+                    boundingBox.maxX + offX, boundingBox.maxY + offY, boundingBox.maxZ + offZ)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+    // Tuinity end - optimise multi-aabb shapes
 }
diff --git a/src/main/java/net/minecraft/server/VoxelShapeSpliterator.java b/src/main/java/net/minecraft/server/VoxelShapeSpliterator.java
index e841611bb7c36dffec44bb9e74a0a9657a113263..259605daabb18aedb15d56c78e6553ae2d22e13f 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeSpliterator.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeSpliterator.java
@@ -91,7 +91,7 @@ public class VoxelShapeSpliterator extends AbstractSpliterator<VoxelShape> {
                 VoxelShape voxelshape = iblockdata.b((IBlockAccess) this.g, this.e, this.c);
 
                 if (voxelshape == VoxelShapes.b()) {
-                    if (!this.b.a((double) i, (double) j, (double) k, (double) i + 1.0D, (double) j + 1.0D, (double) k + 1.0D)) {
+                    if (!this.b.voxelShapeIntersect((double) i, (double) j, (double) k, (double) i + 1.0D, (double) j + 1.0D, (double) k + 1.0D)) { // Tuinity - keep vanilla behavior for voxelshape intersection - See comment in AxisAlignedBB
                         continue;
                     }
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index 9f4f9df09968dc45878ad59f5ee45672a3f08fbd..4bdadffee07c54f6f538ba09db72d562d05cb337 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -17,18 +17,80 @@ public final class VoxelShapes {
 
         voxelshapebitset.a(0, 0, 0, true, true);
         return new VoxelShapeCube(voxelshapebitset);
-    });
+    }); public static final VoxelShape getFullUnoptimisedCube() { return VoxelShapes.b; } // Tuinity - OBFHELPER
     public static final VoxelShape a = create(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
-    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}));
+    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D})); static final VoxelShape getEmptyShape() { return VoxelShapes.c; } // Tuinity - OBFHELPER
+
+    // Tuinity start - optimise voxelshapes
+    public static boolean isEmpty(VoxelShape voxelshape) {
+        // helper function for determining empty shapes fast
+        return voxelshape == getEmptyShape() || voxelshape.isEmpty();
+    }
+    // Tuinity end - optimise voxelshapes
 
     public static final VoxelShape empty() {return a();} // Paper - OBFHELPER
     public static VoxelShape a() {
         return VoxelShapes.c;
     }
 
+    static final com.tuinity.tuinity.voxel.AABBVoxelShape optimisedFullCube = new com.tuinity.tuinity.voxel.AABBVoxelShape(new AxisAlignedBB(0, 0, 0, 1.0, 1.0, 1.0)); // Tuinity - optimise voxelshape
+
+    // Tuinity start - optimise voxelshapes
+    public static void addBoxesToIfIntersects(VoxelShape shape, AxisAlignedBB aabb, java.util.List<AxisAlignedBB> list) {
+        if (shape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape) {
+            com.tuinity.tuinity.voxel.AABBVoxelShape shapeCasted = (com.tuinity.tuinity.voxel.AABBVoxelShape)shape;
+            if (shapeCasted.aabb.voxelShapeIntersect(aabb)) {
+                list.add(shapeCasted.aabb);
+            }
+        } else if (shape instanceof VoxelShapeArray) {
+            VoxelShapeArray shapeCasted = (VoxelShapeArray)shape;
+            // this can be optimised by checking an "overall shape" first, but not needed
+
+            double offX = shapeCasted.offsetX;
+            double offY = shapeCasted.offsetY;
+            double offZ = shapeCasted.offsetZ;
+
+            for (AxisAlignedBB boundingBox : shapeCasted.boundingBoxesRepresentation) {
+                double minX, minY, minZ, maxX, maxY, maxZ;
+                if (aabb.voxelShapeIntersect(minX = boundingBox.minX + offX, minY = boundingBox.minY + offY, minZ = boundingBox.minZ + offZ,
+                        maxX = boundingBox.maxX + offX, maxY = boundingBox.maxY + offY, maxZ = boundingBox.maxZ + offZ)) {
+                    list.add(new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ, false));
+                }
+            }
+        } else {
+            java.util.List<AxisAlignedBB> boxes = shape.getBoundingBoxesRepresentation();
+            for (int i = 0, len = boxes.size(); i < len; ++i) {
+                AxisAlignedBB box = boxes.get(i);
+                if (box.voxelShapeIntersect(aabb)) {
+                    list.add(box);
+                }
+            }
+        }
+    }
+
+    public static void addBoxesTo(VoxelShape shape, java.util.List<AxisAlignedBB> list) {
+        if (shape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape) {
+            com.tuinity.tuinity.voxel.AABBVoxelShape shapeCasted = (com.tuinity.tuinity.voxel.AABBVoxelShape)shape;
+            list.add(shapeCasted.aabb);
+        } else if (shape instanceof VoxelShapeArray) {
+            VoxelShapeArray shapeCasted = (VoxelShapeArray)shape;
+
+            for (AxisAlignedBB boundingBox : shapeCasted.boundingBoxesRepresentation) {
+                list.add(boundingBox.offset(shapeCasted.offsetX, shapeCasted.offsetY, shapeCasted.offsetZ));
+            }
+        } else {
+            java.util.List<AxisAlignedBB> boxes = shape.getBoundingBoxesRepresentation();
+            for (int i = 0, len = boxes.size(); i < len; ++i) {
+                AxisAlignedBB box = boxes.get(i);
+                list.add(box);
+            }
+        }
+    }
+    // Tuinity end - optimise voxelshapes
+
     public static final VoxelShape fullCube() {return b();} // Paper - OBFHELPER
     public static VoxelShape b() {
-        return VoxelShapes.b;
+        return VoxelShapes.optimisedFullCube; // Tuinity - optimise voxelshape
     }
 
     public static VoxelShape create(double d0, double d1, double d2, double d3, double d4, double d5) {
@@ -67,7 +129,7 @@ public final class VoxelShapes {
                 return new VoxelShapeCube(voxelshapebitset);
             }
         } else {
-            return new VoxelShapeArray(VoxelShapes.b.a, new double[]{axisalignedbb.minX, axisalignedbb.maxX}, new double[]{axisalignedbb.minY, axisalignedbb.maxY}, new double[]{axisalignedbb.minZ, axisalignedbb.maxZ});
+            return new com.tuinity.tuinity.voxel.AABBVoxelShape(axisalignedbb); // Tuinity - optimise VoxelShapes for single AABB shapes
         }
     }
 
@@ -132,6 +194,20 @@ public final class VoxelShapes {
 
     public static final boolean applyOperation(VoxelShape voxelshape, VoxelShape voxelshape1, OperatorBoolean operatorboolean) { return VoxelShapes.c(voxelshape, voxelshape1, operatorboolean); } // Paper - OBFHELPER
     public static boolean c(VoxelShape voxelshape, VoxelShape voxelshape1, OperatorBoolean operatorboolean) {
+        // Tuinity start - optimise voxelshape
+        if (operatorboolean == OperatorBoolean.AND) {
+            if (voxelshape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape && voxelshape1 instanceof com.tuinity.tuinity.voxel.AABBVoxelShape) {
+                return ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape).aabb.voxelShapeIntersect(((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape1).aabb);
+            } else if (voxelshape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape && voxelshape1 instanceof VoxelShapeArray) {
+                return ((VoxelShapeArray)voxelshape1).intersects(((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape).aabb);
+            } else if (voxelshape1 instanceof com.tuinity.tuinity.voxel.AABBVoxelShape && voxelshape instanceof VoxelShapeArray) {
+                return ((VoxelShapeArray)voxelshape).intersects(((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape1).aabb);
+            }
+        }
+        return abstract_c(voxelshape, voxelshape1, operatorboolean);
+    }
+    public static boolean abstract_c(VoxelShape voxelshape, VoxelShape voxelshape1, OperatorBoolean operatorboolean) {
+        // Tuinity end - optimise voxelshape
         if (operatorboolean.apply(false, false)) {
             throw (IllegalArgumentException) SystemUtils.c((Throwable) (new IllegalArgumentException()));
         } else if (voxelshape == voxelshape1) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 3d03cefb1a7810da1f64420dd8a6e34feafb826c..6231b04fe92fe91eea7423c12425c4ac96d3a7f3 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1118,8 +1118,13 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
 
     @Override
     public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate) {
-        this.getMethodProfiler().c("getEntities");
+        // Tuinity start - add list parameter
         List<Entity> list = Lists.newArrayList();
+        return this.getEntities(entity, axisalignedbb, predicate, list);
+    }
+    public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate, List<Entity> list) {
+        // Tuinity end - add list parameter
+        this.getMethodProfiler().c("getEntities");
         int i = MathHelper.floor((axisalignedbb.minX - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.maxX + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.minZ - 2.0D) / 16.0D);
diff --git a/src/main/java/net/minecraft/server/WorldBorder.java b/src/main/java/net/minecraft/server/WorldBorder.java
index f011869880fedae4b69e505491e8bdbc5f51dfba..26a8c4ffe26c4663ddb3596dce8c47026aa2d0c3 100644
--- a/src/main/java/net/minecraft/server/WorldBorder.java
+++ b/src/main/java/net/minecraft/server/WorldBorder.java
@@ -47,11 +47,43 @@ public class WorldBorder {
         return axisalignedbb.maxX > this.e() && axisalignedbb.minX < this.g() && axisalignedbb.maxZ > this.f() && axisalignedbb.minZ < this.h();
     }
 
+    // Tuinity start - optimise collisions
+    // determines whether we are colliding with one of the wordborder faces.
+    public final boolean isCollidingOnBorderEdge(AxisAlignedBB boundingBox) {
+        return this.isCollidingOnBorderEdge(boundingBox.minX, boundingBox.maxX, boundingBox.minZ, boundingBox.maxZ);
+    }
+
+    public final boolean isCollidingOnBorderEdge(double boxMinX, double boxMaxX, double boxMinZ, double boxMaxZ) {
+        double minX = this.getMinX() - MCUtil.COLLISION_EPSILON;
+        double maxX = this.getMaxX() + MCUtil.COLLISION_EPSILON;
+
+        double minZ = this.getMinZ() - MCUtil.COLLISION_EPSILON;
+        double maxZ = this.getMaxZ() + MCUtil.COLLISION_EPSILON;
+
+        return
+                // First, check if the worldborder is enclosing the specified box.
+                // We check this first as it's most likely to fail.
+                !(minX < boxMinX && maxX > boxMaxX && minZ < boxMinZ && maxZ > boxMaxZ)
+                &&
+
+                // Now we verify if we're even intersecting.
+                (minX < boxMaxX && maxX > boxMinX && minZ < boxMaxZ && maxZ > boxMinZ)
+                &&
+
+                // Now verify that the worldborder isn't being enclosed.
+                // This is never expected to happen, but is left here to ensure our logic
+                // is right 100% of the time.
+                !(boxMinX < minX && boxMaxX > maxX && boxMinZ < minZ && boxMaxZ > maxZ)
+                ;
+    }
+    // Tuinity end - optimise collisions
+
     public double a(Entity entity) {
         return this.b(entity.locX(), entity.locZ());
     }
 
     public final VoxelShape asVoxelShape(){ return c();} // Paper - OBFHELPER
+    public final VoxelShape getCollisionShape() { return this.c(); } // Tuinity - OBFHELPER
     public VoxelShape c() {
         return this.j.m();
     }
@@ -67,18 +99,22 @@ public class WorldBorder {
         return Math.min(d6, d3);
     }
 
+    public final double getMinX() { return this.e(); } // Tuinity - OBFHELPER
     public double e() {
         return this.j.a();
     }
 
+    public final double getMinZ() { return this.f(); } // Tuinity - OBFHELPER
     public double f() {
         return this.j.c();
     }
 
+    public final double getMaxX() { return this.g(); } // Tuinity - OBFHELPER
     public double g() {
         return this.j.b();
     }
 
+    public final double getMaxZ() { return this.h(); } // Tuinity - OBFHELPER
     public double h() {
         return this.j.d();
     }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 9c55eefc1852edaa03e62a20c2477802f16f4f39..58465833d6ddc43cb4dc1eff8888ee6ee03e9a69 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -356,6 +356,328 @@ public class WorldServer extends World implements GeneratorAccessSeed {
         this.asyncChunkTaskManager = new com.destroystokyo.paper.io.chunk.ChunkTaskManager(this); // Paper
     }
 
+    // Tuinity start - optimise collision
+    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks) {
+        if (entity != null) {
+            if (this.getWorldBorder().isCollidingOnBorderEdge(axisalignedbb)) {
+                return true;
+            }
+        }
+
+        int minBlockX = MathHelper.floor(axisalignedbb.minX - MCUtil.COLLISION_EPSILON) - 1;
+        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + MCUtil.COLLISION_EPSILON) + 1;
+
+        int minBlockY = MathHelper.floor(axisalignedbb.minY - MCUtil.COLLISION_EPSILON) - 1;
+        int maxBlockY = MathHelper.floor(axisalignedbb.maxY + MCUtil.COLLISION_EPSILON) + 1;
+
+        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - MCUtil.COLLISION_EPSILON) - 1;
+        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + MCUtil.COLLISION_EPSILON) + 1;
+
+
+        BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
+        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
+
+        // special cases:
+        if (minBlockY > 255 || maxBlockY < 0) {
+            // no point in checking
+            return false;
+        }
+
+        int minYIterate = Math.max(0, minBlockY);
+        int maxYIterate = Math.min(255, maxBlockY);
+
+        int minChunkX = minBlockX >> 4;
+        int maxChunkX = maxBlockX >> 4;
+
+        int minChunkZ = minBlockZ >> 4;
+        int maxChunkZ = maxBlockZ >> 4;
+
+        ChunkProviderServer chunkProvider = (ChunkProviderServer)this.chunkProvider;
+        // TODO special case single chunk?
+
+        for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+            int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
+            int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 15; // coordinate in chunk
+
+            for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
+                int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
+                int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 15; // coordinate in chunk
+
+                int chunkXGlobalPos = currChunkX << 4;
+                int chunkZGlobalPos = currChunkZ << 4;
+                Chunk chunk = loadChunks ? chunkProvider.getChunkAt(currChunkX, currChunkZ, true) : chunkProvider.getChunkAtIfLoadedImmediately(currChunkX, currChunkZ);
+
+                if (chunk == null) {
+                    return true;
+                }
+
+                ChunkSection[] sections = chunk.getSections();
+
+                // bound y
+
+                for (int currY = minYIterate; currY <= maxYIterate; ++currY) {
+                    ChunkSection section = sections[currY >>> 4];
+                    if (section == null || section.isFullOfAir()) {
+                        // empty
+                        // skip to next section
+                        currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
+                        continue;
+                    }
+
+                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
+                    int blockKeyY = (currY & 15) << 8;
+
+                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
+
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        int blockKeyXY = blockKeyY | currX;
+                        int blockX = currX | chunkXGlobalPos; // world position
+
+                        int edgeCountXY;
+                        if (blockX == minBlockX || blockX == maxBlockX) {
+                            edgeCountXY = edgeCountY + 1;
+                        } else {
+                            edgeCountXY = edgeCountY;
+                        }
+
+                        for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                            int blockZ = currZ | chunkZGlobalPos; // world position
+
+                            int edgeCountFull;
+                            if (blockZ == minBlockZ || blockZ == maxBlockZ) {
+                                edgeCountFull = edgeCountXY + 1;
+                            } else {
+                                edgeCountFull = edgeCountXY;
+                            }
+
+                            if (edgeCountFull == 3) {
+                                continue;
+                            }
+
+                            int blockKeyFull = blockKeyXY | (currZ << 4);
+                            IBlockData blockData = blocks.rawGet(blockKeyFull);
+
+                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
+                                mutablePos.setValues(blockX, currY, blockZ);
+                                VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
+                                if (voxelshape2 != VoxelShapes.getEmptyShape()) {
+                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
+
+                                    if (voxelshape3.intersects(axisalignedbb)) {
+                                        return true;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public final boolean hardCollidesWithAnyEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<Entity> predicate) {
+        if (axisalignedbb.isEmpty()) {
+            return false;
+        }
+        axisalignedbb = axisalignedbb.grow(MCUtil.COLLISION_EPSILON, MCUtil.COLLISION_EPSILON, MCUtil.COLLISION_EPSILON);
+        List<Entity> entities = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList();
+        try {
+            if (entity != null && entity.hardCollides()) {
+                this.getEntities(entity, axisalignedbb, predicate, entities);
+            } else {
+                this.getHardCollidingEntities(entity, axisalignedbb, predicate, entities);
+            }
+
+            for (int i = 0, len = entities.size(); i < len; ++i) {
+                Entity otherEntity = entities.get(i);
+
+                if ((entity == null || otherEntity.collisionBoxIsHard()) || entity.hardCollidesWith(otherEntity)) {
+                    return true;
+                }
+            }
+
+            return false;
+        } finally {
+            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(entities);
+        }
+    }
+
+    public final boolean hasAnyCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+        return this.hasAnyCollisions(entity, axisalignedbb, true);
+    }
+
+    public final boolean hasAnyCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks) {
+        return this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, loadChunks) || this.hardCollidesWithAnyEntities(entity, axisalignedbb, null);
+    }
+
+    // Tuinity start - optimise collision
+    public void getCollisionsForBlocksOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, boolean loadChunks) {
+        if (entity != null) {
+            if (this.getWorldBorder().isCollidingOnBorderEdge(axisalignedbb)) {
+                VoxelShapes.addBoxesTo(this.getWorldBorder().getCollisionShape(), list);
+            }
+        }
+
+        int minBlockX = MathHelper.floor(axisalignedbb.minX - MCUtil.COLLISION_EPSILON) - 1;
+        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + MCUtil.COLLISION_EPSILON) + 1;
+
+        int minBlockY = MathHelper.floor(axisalignedbb.minY - MCUtil.COLLISION_EPSILON) - 1;
+        int maxBlockY = MathHelper.floor(axisalignedbb.maxY + MCUtil.COLLISION_EPSILON) + 1;
+
+        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - MCUtil.COLLISION_EPSILON) - 1;
+        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + MCUtil.COLLISION_EPSILON) + 1;
+
+
+        BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
+        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
+
+        // special cases:
+        if (minBlockY > 255 || maxBlockY < 0) {
+            // no point in checking
+            return;
+        }
+
+        int minYIterate = Math.max(0, minBlockY);
+        int maxYIterate = Math.min(255, maxBlockY);
+
+        int minChunkX = minBlockX >> 4;
+        int maxChunkX = maxBlockX >> 4;
+
+        int minChunkZ = minBlockZ >> 4;
+        int maxChunkZ = maxBlockZ >> 4;
+
+        ChunkProviderServer chunkProvider = (ChunkProviderServer)this.chunkProvider;
+        // TODO special case single chunk?
+
+        for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+            int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
+            int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 15; // coordinate in chunk
+
+            for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
+                int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
+                int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 15; // coordinate in chunk
+
+                int chunkXGlobalPos = currChunkX << 4;
+                int chunkZGlobalPos = currChunkZ << 4;
+                Chunk chunk = loadChunks ? chunkProvider.getChunkAt(currChunkX, currChunkZ, true) : chunkProvider.getChunkAtIfLoadedImmediately(currChunkX, currChunkZ);
+
+                if (chunk == null) {
+                    list.add(AxisAlignedBB.getBoxForChunk(currChunkX, currChunkZ));
+                    continue;
+                }
+
+                ChunkSection[] sections = chunk.getSections();
+
+                // bound y
+
+                for (int currY = minYIterate; currY <= maxYIterate; ++currY) {
+                    ChunkSection section = sections[currY >>> 4];
+                    if (section == null || section.isFullOfAir()) {
+                        // empty
+                        // skip to next section
+                        currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
+                        continue;
+                    }
+
+                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
+                    int blockKeyY = (currY & 15) << 8;
+
+                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
+
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        int blockKeyXY = blockKeyY | currX;
+                        int blockX = currX | chunkXGlobalPos; // world position
+
+                        int edgeCountXY;
+                        if (blockX == minBlockX || blockX == maxBlockX) {
+                            edgeCountXY = edgeCountY + 1;
+                        } else {
+                            edgeCountXY = edgeCountY;
+                        }
+
+                        for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                            int blockZ = currZ | chunkZGlobalPos; // world position
+
+                            int edgeCountFull;
+                            if (blockZ == minBlockZ || blockZ == maxBlockZ) {
+                                edgeCountFull = edgeCountXY + 1;
+                            } else {
+                                edgeCountFull = edgeCountXY;
+                            }
+
+                            if (edgeCountFull == 3) {
+                                continue;
+                            }
+
+                            int blockKeyFull = blockKeyXY | (currZ << 4);
+                            IBlockData blockData = blocks.rawGet(blockKeyFull);
+
+                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
+                                mutablePos.setValues(blockX, currY, blockZ);
+                                VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
+                                if (voxelshape2 != VoxelShapes.getEmptyShape()) {
+                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
+
+                                    VoxelShapes.addBoxesToIfIntersects(voxelshape3, axisalignedbb, list);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public final void getEntityHardCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<Entity> predicate, List<AxisAlignedBB> list) {
+        if (axisalignedbb.isEmpty()) {
+            return;
+        }
+        axisalignedbb = axisalignedbb.grow(MCUtil.COLLISION_EPSILON, MCUtil.COLLISION_EPSILON, MCUtil.COLLISION_EPSILON);
+        List<Entity> entities = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList();
+        try {
+            if (entity != null && entity.hardCollides()) {
+                this.getEntities(entity, axisalignedbb, predicate, entities);
+            } else {
+                this.getHardCollidingEntities(entity, axisalignedbb, predicate, entities);
+            }
+
+            for (int i = 0, len = entities.size(); i < len; ++i) {
+                Entity otherEntity = entities.get(i);
+
+                if ((entity == null || otherEntity.collisionBoxIsHard()) || entity.hardCollidesWith(otherEntity)) {
+                    list.add(otherEntity.getBoundingBox());
+                }
+            }
+        } finally {
+            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(entities);
+        }
+    }
+
+    public final void getCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, boolean loadChunks) {
+        this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, list, loadChunks);
+        this.getEntityHardCollisions(entity, axisalignedbb, null, list);
+    }
+
+    @Override
+    public boolean getCubes(Entity entity) {
+        return !this.hasAnyCollisions(entity, entity.getBoundingBox());
+    }
+
+    @Override
+    public boolean getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+        if (entity instanceof EntityArmorStand && !entity.world.paperConfig.armorStandEntityLookups) return false;
+        return !this.hasAnyCollisions(entity, axisalignedbb);
+    }
+
+    @Override
+    public boolean getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
+        if (entity instanceof EntityArmorStand && !entity.world.paperConfig.armorStandEntityLookups) return false;
+        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, true) && !this.hardCollidesWithAnyEntities(entity, axisalignedbb, predicate);
+    }
+    // Tuinity end - optimise collision
+
     // CraftBukkit start
     @Override
     protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java b/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
index f72c13bedaa6fa45e26f5dcad564835bdd4af61f..50f855b931dba60754fff9c7cdf5e0e744f00fdd 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
@@ -119,6 +119,32 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         return indexOf(o) >= 0;
     }
 
+    // Tuinity start
+    protected transient int maxSize;
+    public void setSize(int size) {
+        if (this.maxSize < this.size) {
+            this.maxSize = this.size;
+        }
+        this.size = size;
+    }
+
+    public void completeReset() {
+        if (this.data != null) {
+            Arrays.fill(this.data, 0, Math.max(this.size, this.maxSize), null);
+        }
+        this.size = 0;
+        this.maxSize = 0;
+        if (this.iterPool != null) {
+            for (Iterator temp : this.iterPool) {
+                if (temp == null) {
+                    continue;
+                }
+                ((Itr)temp).valid = false;
+            }
+        }
+    }
+    // Tuinity end
+
     @Override
     public void clear() {
         // Create new array to reset memory usage to initial capacity
